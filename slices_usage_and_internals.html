
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Go Slices: usage and internals &#8212; Go database/sql tutorial  ドキュメント</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="Go Concurrency Patterns: Context" href="context.html" />
    <link rel="prev" title="The Go Blog" href="index.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <a href="https://github.com/d-tsuji/go-introduction-book"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a><div class="section" id="go-slices-usage-and-internals">
<h1>Go Slices: usage and internals<a class="headerlink" href="#go-slices-usage-and-internals" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Goのslice型は型付けされたデータの配列を操作する便利で効率的な方法を提供します。スライスは他の言語でいうところの配列に似ていますが、いくつかの特徴があります。本記事ではスライスの概要と使用方法を説明します。</p>
<div class="section" id="id1">
<h2>配列<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>slice型はGoの配列型の上に構築されている抽象化であるため、スライスを理解するためには、まず配列を理解する必要があります。</p>
<p>配列型の定義は、配列の長さと要素の型を指定します。例えば、型 <code class="docutils literal notranslate"><span class="pre">[4]int</span></code> は4つの整数を格納する配列を表します。配列のサイズは固定されています。その長さはその型の一部です( <code class="docutils literal notranslate"><span class="pre">[4]int</span></code> と <code class="docutils literal notranslate"><span class="pre">[5]int</span></code> は別の型です)。配列には通常の方法でインデックスを付けることができるため、式 <code class="docutils literal notranslate"><span class="pre">s[n]</span></code> は0から始まる <em>n</em> 番目の要素にアクセスします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span>
<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1</span>
<span class="nx">i</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1">// i == 1</span>
</pre></div>
</div>
<p>配列は明示的に初期化をする必要がありません。配列のゼロ値は、要素自体がゼロ値で初期化されているすぐに使用できる配列です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// a[2] == 0, the zero value of the int type</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">[4]int</span></code> のメモリ上での表現は、連続して配置された4つの整数値です。</p>
<img alt="_images/go-slices-usage-and-internals_slice-array.png" src="_images/go-slices-usage-and-internals_slice-array.png" />
<p>Goの配列は値です。配列の変数は、配列全体を示します。(Cの場合のように)配列の最初の要素へのポインタではありません。これは、配列の値を割り当てたり、関数に渡したりすると、その内容のコピーが作成されることを意味します。(コピーを回避するために、配列への <em>ポインタ</em> を渡すことができますが、それは配列ではなく配列へのポインタです。)配列について考える1つの方法は、固定サイズの複合値のような名前付きフィールドではなく、インデックス付きフィールドのような構造です。</p>
<p>配列のリテラルは次のように指定できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Penn&quot;</span><span class="p">,</span> <span class="s">&quot;Teller&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>または、コンパイラに配列の要素をカウントさせることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">b</span> <span class="o">:=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Penn&quot;</span><span class="p">,</span> <span class="s">&quot;Teller&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>いずれの場合も <code class="docutils literal notranslate"><span class="pre">b</span></code> の型は <code class="docutils literal notranslate"><span class="pre">[2]string</span></code> です。</p>
</div>
<div class="section" id="id2">
<h2>スライス<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>配列はGoに含まれていますが、少し柔軟性に欠けるため、Goのコードではあまり頻繁に表れません。ただし、スライスはよく見かけます。配列上に構築され、優れた力と利便性を提供します。</p>
<p>スライスの型指定は <code class="docutils literal notranslate"><span class="pre">[]T</span></code> です。<code class="docutils literal notranslate"><span class="pre">T</span></code> はスライスの要素の型です。配列型とは異なり、スライス型には長さが指定されていません。</p>
<p>スライスのリテラルは、要素の数を省略したことを除いて、配列のリテラルと同様に宣言されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">letters</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>スライスは <code class="docutils literal notranslate"><span class="pre">make</span></code> という組み込み関数を使用して作成できます。これには以下のようなシグネチャがあります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">len</span><span class="p">,</span> <span class="nx">cap</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>
</pre></div>
</div>
<p>Tは、作成するスライスの要素の型です。<code class="docutils literal notranslate"><span class="pre">make</span></code> 関数は、型、長さ、およびオプションの容量を取ります。呼び出されると、<code class="docutils literal notranslate"><span class="pre">make</span></code> は配列を割り当て、その配列を参照するスライスを返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">byte</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="c1">// s == []byte{0, 0, 0, 0, 0}</span>
</pre></div>
</div>
<p>容量の引数を省略すると、デフォルトで長さの引数と同じになります。上記と同じコードでより簡潔なバージョンを次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">s</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>組み込みの <code class="docutils literal notranslate"><span class="pre">len</span></code> および <code class="docutils literal notranslate"><span class="pre">cap</span></code> 関数を使用して、スライスの長さと容量を調べることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
<span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>次の2つのセクションでは、長さと容量の関係について説明します。</p>
<p>スライスのゼロ値は <code class="docutils literal notranslate"><span class="pre">nil</span></code> です。<code class="docutils literal notranslate"><span class="pre">len</span></code> や <code class="docutils literal notranslate"><span class="pre">cap</span></code> 関数はnilスライスとして0を返します。</p>
<p>スライスは、既存のスライスまたは配列を「スライス」することでも作ることができます。スライスは、コロンで区切られた2つのインデックスで半開区間を指定することによって作成されます。例えば、<code class="docutils literal notranslate"><span class="pre">b[1：4]</span></code> は、<code class="docutils literal notranslate"><span class="pre">b</span></code> の1から3のインデックスの要素を含むスライスを作成します(結果のスライスのインデックスは0～2になります)。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;g&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;n&#39;</span><span class="p">,</span> <span class="sc">&#39;g&#39;</span><span class="p">}</span>
<span class="c1">// b[1:4] == []byte{&#39;o&#39;, &#39;l&#39;, &#39;a&#39;}, sharing the same storage as b</span>
</pre></div>
</div>
<p>スライス式の開始インデックスと終了インデックスはオプションです。デフォルトはそれぞれゼロとスライスの長さです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// b[:2] == []byte{&#39;g&#39;, &#39;o&#39;}</span>
<span class="c1">// b[2:] == []byte{&#39;l&#39;, &#39;a&#39;, &#39;n&#39;, &#39;g&#39;}</span>
<span class="c1">// b[:] == b</span>
</pre></div>
</div>
<p>以下は与えられた配列からスライスを作成する構文の一つです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">x</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;Лайка&quot;</span><span class="p">,</span> <span class="s">&quot;Белка&quot;</span><span class="p">,</span> <span class="s">&quot;Стрелка&quot;</span><span class="p">}</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">[:]</span> <span class="c1">// a slice referencing the storage of x</span>
</pre></div>
</div>
</div>
<div class="section" id="id3">
<h2>スライスの内部構造<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスは、配列セグメントの記述子です。これは、配列へのポインター、セグメントの長さ、およびその容量(セグメントの最大長)で構成されています。</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">課題</p>
<p>どのように訳すと自然か。</p>
<p>A slice is a descriptor of an array segment. It consists of a pointer to
the array, the length of the segment, and its capacity (the maximum
length of the segment).</p>
</div>
<img alt="_images/go-slices-usage-and-internals_slice-struct.png" src="_images/go-slices-usage-and-internals_slice-struct.png" />
<p>変数 <code class="docutils literal notranslate"><span class="pre">s</span></code> はまず <code class="docutils literal notranslate"><span class="pre">make([]byte,</span> <span class="pre">5)</span></code> によって作成され、以下のような構造になっています。</p>
<img alt="_images/go-slices-usage-and-internals_slice-1.png" src="_images/go-slices-usage-and-internals_slice-1.png" />
<p>長さは、スライスによって参照される要素の数です。容量は、基になる配列内の要素の数です(スライスポインターによって参照される要素から始まります)。次のいくつかの例を見ていくと、長さと容量の違いが明確になります。</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>重要なポイント</p>
<ul class="simple">
<li><p>長さは、スライスによって参照される要素の数</p></li>
<li><p>容量は、基になる配列内の要素の数</p></li>
</ul>
</div>
<p>次のように <code class="docutils literal notranslate"><span class="pre">s</span></code> をスライスするとき、スライスのデータ構造の変化と、基になる配列との関係を観察します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<img alt="_images/go-slices-usage-and-internals_slice-2.png" src="_images/go-slices-usage-and-internals_slice-2.png" />
<p>スライスは、スライスのデータをコピーしません。元の配列を指す新しいスライス値を作成します。これにより、配列インデックスを操作するのと同じくらい効率的にスライス操作ができます。したがって、再スライスの <em>要素</em> (スライス自体ではない)を変更すると、元のスライスの要素が変更されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">d</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="sc">&#39;r&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;d&#39;</span><span class="p">}</span>
<span class="nx">e</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="c1">// e == []byte{&#39;a&#39;, &#39;d&#39;}</span>
<span class="nx">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;m&#39;</span>
<span class="c1">// e == []byte{&#39;a&#39;, &#39;m&#39;}</span>
<span class="c1">// d == []byte{&#39;r&#39;, &#39;o&#39;, &#39;a&#39;, &#39;m&#39;}</span>
</pre></div>
</div>
<p>先に <code class="docutils literal notranslate"><span class="pre">s</span></code> をその容量よりも短い長さにスライスしました。再びスライスすることで、容量を増やすことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[:</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)]</span>
</pre></div>
</div>
<img alt="_images/go-slices-usage-and-internals_slice-3.png" src="_images/go-slices-usage-and-internals_slice-3.png" />
<p>スライスは容量を超えて増やすことはできません。スライスまたは配列の境界外でインデックスを作成するときと同様に、そうしようとすると、実行時パニックが発生します。同様に、配列内の以前の要素にアクセスするために、スライスを0未満にスライスすることはできません。</p>
</div>
<div class="section" id="append">
<h2>スライスの拡張(コピーと <code class="docutils literal notranslate"><span class="pre">append</span></code> 関数)<a class="headerlink" href="#append" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスの容量を増やすには、新しい大きなスライスを作成し、元のスライスの内容をそこにコピーする必要があります。内部的には、他言語の動的な配列実装のテクニックを用いています。次の例では、新しいスライス <code class="docutils literal notranslate"><span class="pre">t</span></code> を作成し、<code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">``の内容を</span> <span class="pre">``t</span></code> にコピーし、スライス値 <code class="docutils literal notranslate"><span class="pre">t</span></code> を <code class="docutils literal notranslate"><span class="pre">s</span></code> に割り当てることにより、<code class="docutils literal notranslate"><span class="pre">s</span></code> の容量を2倍にします。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// +1 in case cap(s) == 0</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
        <span class="nx">t</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nx">t</span>
</pre></div>
</div>
<p>ループの中の上記のよく見る操作は、組み込みの <code class="docutils literal notranslate"><span class="pre">copy</span></code> 関数によって簡単になります。名前が示すように、<code class="docutils literal notranslate"><span class="pre">copy</span></code> は元のスライスから宛先のスライスにデータをコピーします。コピーされた要素の数を返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nb">copy</span><span class="p">(</span><span class="nx">dst</span><span class="p">,</span> <span class="nx">src</span> <span class="p">[]</span><span class="nx">T</span><span class="p">)</span> <span class="kt">int</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> 関数は、異なる長さのスライス間のコピーをサポートします(要素の数が少ない場合のみコピーします)。さらに <code class="docutils literal notranslate"><span class="pre">copy</span></code> は基となる配列を共有する、元のスライスと宛先のスライスを扱うことができます。重複するスライスを正しく処理できます。</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> を使うことで、上記のコードスニペットは以下のようにシンプルになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">t</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="p">(</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">copy</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nx">t</span>
</pre></div>
</div>
<p>よく使われる操作は、スライスの最後にデータを追加することです。以下の関数は、バイトのスライスにバイト要素を追加し、必要に応じてスライスを拡大し、更新されたスライス値を返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">AppendByte</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">data</span> <span class="o">...</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
   <span class="nx">m</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
   <span class="nx">n</span> <span class="o">:=</span> <span class="nx">m</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
   <span class="k">if</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// if necessary, reallocate</span>
      <span class="c1">// allocate double what&#39;s needed, for future growth.</span>
      <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="p">(</span><span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
      <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
      <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
   <span class="p">}</span>
   <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="nx">n</span><span class="p">]</span>
   <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">m</span><span class="p">:</span><span class="nx">n</span><span class="p">],</span> <span class="nx">data</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> は使用例は以下です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">p</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="nx">p</span> <span class="p">=</span> <span class="nx">AppendByte</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="c1">// p == []byte{2, 3, 5, 7, 11, 13}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> などの関数は、スライスの成長方法を完全に制御できるため便利です。プログラムの特性に応じて、小さいチャンクまたは大きいチャンクに割り当てるか、再割り当てのサイズに上限を設けることが望ましい場合があります。</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">課題</p>
<p>slice の grown は成長と訳すのがいいのかどうか。</p>
<p><code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> などの関数は、スライスの成長方法を完全に制御できるため便利です。</p>
<p>Functions like <code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> are useful because they offer complete control over the way the slice is grown.</p>
</div>
<p>しかし、ほとんどのプログラムは完全な制御を必要としないため、Goはたいていの目的に適した組み込みの <code class="docutils literal notranslate"><span class="pre">append</span></code> 関数を提供します。以下のようなシグネチャです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="nx">T</span><span class="p">,</span> <span class="nx">x</span> <span class="o">...</span><span class="nx">T</span><span class="p">)</span> <span class="p">[]</span><span class="nx">T</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">append</span></code> 関数はスライス <code class="docutils literal notranslate"><span class="pre">s</span></code> の最後に要素 <code class="docutils literal notranslate"><span class="pre">x</span></code> を追加し、容量を大きくする必要があればスライスを拡張します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1">// a == []int{0}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="c1">// a == []int{0, 1, 2, 3}</span>
</pre></div>
</div>
<p>スライスを別のスライスに追加するには <a href="#id6"><span class="problematic" id="id7">``</span></a>...` を用いて、2番目の引数に、リストの引数を渡します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">a</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="s">&quot;Paul&quot;</span><span class="p">}</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&quot;George&quot;</span><span class="p">,</span> <span class="s">&quot;Ringo&quot;</span><span class="p">,</span> <span class="s">&quot;Pete&quot;</span><span class="p">}</span>
<span class="nx">a</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="o">...</span><span class="p">)</span> <span class="c1">// equivalent to &quot;append(a, b[0], b[1], b[2])&quot;</span>
<span class="c1">// a == []string{&quot;John&quot;, &quot;Paul&quot;, &quot;George&quot;, &quot;Ringo&quot;, &quot;Pete&quot;}</span>
</pre></div>
</div>
<p>スライスのゼロ値(nil)は長さ0のスライスのように機能するため、スライス変数を宣言してループに追加できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Filter returns a new slice holding only</span>
<span class="c1">// the elements of s that satisfy fn()</span>
<span class="kd">func</span> <span class="nx">Filter</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">fn</span> <span class="kd">func</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
   <span class="kd">var</span> <span class="nx">p</span> <span class="p">[]</span><span class="kt">int</span> <span class="c1">// == nil</span>
   <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">s</span> <span class="p">{</span>
      <span class="k">if</span> <span class="nx">fn</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="nx">p</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h2>落とし穴<a class="headerlink" href="#id8" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前述のように、スライスからスライスを切り出しても、基となる配列のコピーは作成されません。配列全体は、参照されなくなるまでメモリに保持されます。場合によっては、必要なデータの一部のみが必要なときに、プログラムがすべてのスライスのデータをメモリに保持することがあります。</p>
<p>たとえば、この <code class="docutils literal notranslate"><span class="pre">FindDigits</span></code> 関数はファイルをメモリにロードし、連続する数字の最初のグループを検索して、新しいスライスとして返します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">digitRegexp</span> <span class="p">=</span> <span class="nx">regexp</span><span class="p">.</span><span class="nx">MustCompile</span><span class="p">(</span><span class="s">&quot;[0-9]+&quot;</span><span class="p">)</span>

<span class="kd">func</span> <span class="nx">FindDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
   <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nx">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このコードは仕様の通りに動作しますが、返される <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> はファイル全体を含む配列を指します。スライスは基の配列を参照するため、スライスがガベージコレクターの対象にならない限り、配列を解放することはできません。ファイルの一部しか使わないにもかかわらず、ファイルの内容全体をメモリに保持します。</p>
<p>この問題を改善するために、もとのファイルのデータを新しいスライスにコピーしてから返すことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">CopyDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
   <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
   <span class="nx">b</span> <span class="p">=</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nx">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
   <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">b</span><span class="p">))</span>
   <span class="nb">copy</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>[訳注] <code class="docutils literal notranslate"><span class="pre">append</span></code> を用いる場合の例を示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">CopyDigits</span><span class="p">(</span><span class="nx">filename</span> <span class="kt">string</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
   <span class="nx">b</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ioutil</span><span class="p">.</span><span class="nx">ReadFile</span><span class="p">(</span><span class="nx">filename</span><span class="p">)</span>
   <span class="nx">b</span> <span class="p">=</span> <span class="nx">digitRegexp</span><span class="p">.</span><span class="nx">Find</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>
   <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="nx">b</span><span class="o">...</span><span class="p">)</span>
   <span class="k">return</span> <span class="nx">c</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<p>この関数のより簡潔なバージョンは、<code class="docutils literal notranslate"><span class="pre">append</span></code> を使用して実装できます。これは読者の演習にしましょう。</p>
</div>
<div class="section" id="id9">
<h2>関連資料<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><a class="reference external" href="/doc/effective_go.html">Effective Go</a> には <a class="reference external" href="/doc/effective_go.html#slices">スライス</a> と <a class="reference external" href="/doc/effective_go.html#arrays">配列</a> の詳細な処理が含まれており、Goの <a class="reference external" href="/doc/go_spec.html">言語仕様</a> では <a class="reference external" href="/doc/effective_go.html#slices">スライス</a> とそれに <a class="reference external" href="/doc/go_spec.html#Length_and_capacity">関連する</a> <a class="reference external" href="/doc/go_spec.html#Making_slices_maps_and_channels">ヘルパー</a> <a class="reference external" href="/doc/go_spec.html#Appending_and_copying_slices">関数</a> が定義されています。</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div id="toc" class="sidebarRow">
    <h5><a href="index.html">The Go Blog</a></h5>
    <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Go Slices: usage and internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="context.html">Go Concurrency Patterns: Context</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="todo.html">TODO(内部用)</a></li>
</ul>

    
</div>

<style type="text/css">
    .toctree-l1 {
        font-size: 12px;
        margin-bottom: 0;
        font-stretch: normal;
        font-style: normal;
        line-height: 1.33;
        padding-bottom: 5px;
        margin: 2px;
    }
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;VividCortex (translated by @d-tsuji).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/slices_usage_and_internals.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>