
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>Arrays, slices (and strings): The mechanics of &#39;append&#39; &#8212; Go database/sql tutorial  ドキュメント</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="Go Slices: usage and internals" href="slices_usage_and_internals.html" />
    <link rel="prev" title="Go Concurrency Patterns: Context" href="context.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <a href="https://github.com/d-tsuji/go-blog-ja"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a><div class="section" id="arrays-slices-and-strings-the-mechanics-of-append">
<h1>Arrays, slices (and strings): The mechanics of 'append'<a class="headerlink" href="#arrays-slices-and-strings-the-mechanics-of-append" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p>Arrays, slices (and strings): The mechanics of 'append'
26 Sep 2013
Tags: array, slice, string, copy, append</p>
<p>Rob Pike</p>
<hr class="docutils" />
<div class="section" id="id1">
<h2>概要<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>手続き型プログラミング言語の最も一般的な機能の1つは、配列の概念です。配列は単純なもののように見えますが、言語に追加する際に検討しなければならない質問がたくさんあります。</p>
<ul class="simple">
<li><p>固定長か可変長か</p></li>
<li><p>大きさは型の一部かどうか</p></li>
<li><p>多次元配列がどのように見えるか</p></li>
<li><p>空配列はどのような意味を持つか</p></li>
</ul>
<p>これらの質問に対する答えは、配列が言語の単なる特徴であるか、その言語設計の中核部分であるかどうかに影響します。</p>
<p>Goの初期の開発では、設計が正しく感じられるまでにこれらの質問に対する答えを決定するのに約1年かかりました。重要なステップは、柔軟性のある拡張可能なデータ構造を提供するために固定サイズの <em>配列</em> に基づいて構築された <em>スライス</em> の導入でした。しかし、今日に至るまで、Goを初めて使用するプログラマーは、スライスの動作方法につまずくことがよくあります。これは、おそらく他の言語の経験による先入観によるためです。</p>
<p>この投稿では、上記のような混乱を解消することを試みます。このために、組み込み関数の <code class="docutils literal notranslate"><span class="pre">append</span></code> がどのように機能するか、なぜ機能するのかを説明します。</p>
</div>
<div class="section" id="id2">
<h2>配列<a class="headerlink" href="#id2" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>配列はGoの重要な構成要素ですが、建物の基盤のように、より可視的なコンポーネントの下に隠れていることがよくあります。スライスのより興味深く、強力で、目立つアイデアに移る前に、それらについて簡単に話さなければなりません。</p>
<p>配列のサイズはその型の一部であり、表現力を制限するため、配列はGoプログラムではあまり見られません。</p>
<p>以下のように宣言します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">buffer</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">byte</span>
</pre></div>
</div>
<p>256バイトを保持する変数 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> を宣言します。<code class="docutils literal notranslate"><span class="pre">buffer</span></code> の型には、そのサイズ <code class="docutils literal notranslate"><span class="pre">[256]byte</span></code> が含まれます。 512バイトの配列は、異なる型 <code class="docutils literal notranslate"><span class="pre">[512]byte</span></code> になります。</p>
<p>配列に関連付けられているデータは、要素の配列です。概略的には、メモリ内のバッファは次のようになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">buffer</span><span class="p">:</span> <span class="kt">byte</span> <span class="kt">byte</span> <span class="kt">byte</span> <span class="o">...</span> <span class="mi">256</span> <span class="nx">times</span> <span class="o">...</span> <span class="kt">byte</span> <span class="kt">byte</span> <span class="kt">byte</span>
</pre></div>
</div>
<p>つまり、変数は256バイトのデータを保持し、それ以外は何も保持しません。 <code class="docutils literal notranslate"><span class="pre">buffer[255]</span></code> を介して、おなじみのインデックス構文 <code class="docutils literal notranslate"><span class="pre">buffer[0]</span></code> 、<code class="docutils literal notranslate"><span class="pre">buffer[1]</span></code> などでその要素にアクセスできます。(インデックス範囲0〜255は256要素をカバーします。)この範囲外の値でバッファをインデックス付けしようとすると、プログラムがクラッシュします。</p>
<p><code class="docutils literal notranslate"><span class="pre">len</span></code> と呼ばれる組み込み関数があり、配列またはスライスの要素数と、他のいくつかのデータ型の要素数を返します。配列の場合 <code class="docutils literal notranslate"><span class="pre">len</span></code> が返すものは明らかです。この例では <code class="docutils literal notranslate"><span class="pre">len(buffer)</span></code> は固定値256を返します。</p>
<p>配列が使われる用途はあります。例えば、変換行列の適切に表現します。しかしGoで最も一般的な目的は、スライスのためのストレージを保持することです。</p>
</div>
<div class="section" id="id3">
<h2>スライス: スライスヘッダー<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスはよく使われますが、それらをうまく使用するには、スライスが何であり、何をするのかを正確に理解する必要があります。</p>
<p>スライスは、スライス変数自体とは別に保存される配列の連続したセクションを記述するデータ構造です。 <em>スライスは配列ではありません</em> 。スライスは配列の一部を <em>表します</em> 。</p>
<p>前のセクションの <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 配列変数を使用して、配列を <em>スライスする</em> ことにより、要素が100～150(正確には100〜149を含む)を表すスライスを作成できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">=</span> <span class="nx">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">150</span><span class="p">]</span>
</pre></div>
</div>
<p>このスニペットでは、完全な変数宣言を明示的に使用しました。変数 <code class="docutils literal notranslate"><span class="pre">slice``の型は</span> <span class="pre">``[]byte</span></code> で「バイトのスライス」と発音され <code class="docutils literal notranslate"><span class="pre">buffer</span></code> と呼ばれる配列から、要素100(含む)から150(含まない)をスライスすることによって初期化されます。より慣用的な構文は、初期化式によって設定される型を除きます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">slice</span> <span class="p">=</span> <span class="nx">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">150</span><span class="p">]</span>
</pre></div>
</div>
<p>関数内では、以下の簡略した宣言を使用できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">:</span><span class="mi">150</span><span class="p">]</span>
</pre></div>
</div>
<p>上記の slice 変数とは正確には何ですか？完全な話ではありませんが、現時点では、スライスを、長さと配列の要素へのポインタという2つの要素を持つ小さなデータ構造と考えてください。背後で次のように構築されていると考えることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">sliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Length</span>        <span class="kt">int</span>
        <span class="nx">ZerothElement</span> <span class="o">*</span><span class="kt">byte</span>
<span class="p">}</span>

<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">sliceHeader</span><span class="p">{</span>
        <span class="nx">Length</span><span class="p">:</span>        <span class="mi">50</span><span class="p">,</span>
        <span class="nx">ZerothElement</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">buffer</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
<p>もちろん、これは単なる例です。このスニペットは <code class="docutils literal notranslate"><span class="pre">sliceHeader</span></code> と記しているにもかかわらず、構造体はプログラマに公開されていません。要素ポインタの型は要素の型に依存しますが、これは一般的な考え方です。</p>
<p>これまで、配列に対してスライス操作を使用しましたが、次のようにスライスをスライスすることもできます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice2</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p>前と同じように、この操作は新しいスライスを作成します。この場合、元のスライスの要素5～9(両端を含む)で、元の配列の要素105〜109を意味します。 <code class="docutils literal notranslate"><span class="pre">slice2</span></code> 変数の基礎となる <code class="docutils literal notranslate"><span class="pre">sliceHeader</span></code> 構造体は次のようになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice2</span> <span class="o">:=</span> <span class="nx">sliceHeader</span><span class="p">{</span>
        <span class="nx">Length</span><span class="p">:</span>        <span class="mi">5</span><span class="p">,</span>
        <span class="nx">ZerothElement</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">buffer</span><span class="p">[</span><span class="mi">105</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
<p>このヘッダーは、 <code class="docutils literal notranslate"><span class="pre">buffer</span></code> 変数に格納されている同じ基となる配列を引き続き指していることに注意してください。</p>
<p>スライスを <em>再スライス</em> することもできます。つまり、スライスをスライスして、元のスライス構造に結果を保存します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">slice</span></code> 変数の <code class="docutils literal notranslate"><span class="pre">sliceHeader</span></code> 構造は <code class="docutils literal notranslate"><span class="pre">slice2</span></code> 変数の場合と同じように見えます。スライスを切り捨てるなど、頻繁に使用される再スライスが表示されます。次のステートメントは、スライスの最初と最後の要素を削除します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<p>[演習：この割り当て後 <code class="docutils literal notranslate"><span class="pre">sliceHeader</span></code> 構造体がどのように見えるかを記述します。]</p>
<p>経験豊富なGoプログラマーが「スライスヘッダー」について語るのをよく耳にします。これは実際にスライス変数に格納されているからです。たとえば、 <a class="reference external" href="https://golang.org/pkg/bytes/#IndexRune">bytes.IndexRune</a> など、スライスを引数として取る関数を呼び出すと、そのヘッダーが関数に渡されます。この呼び出しでは、</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slashPos</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">IndexRune</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">IndexRune</span></code> 関数に渡される <code class="docutils literal notranslate"><span class="pre">slice</span></code> 引数は、実際には「スライスヘッダー」です。</p>
<p>スライスヘッダーにはもう1つのデータ項目がありますが、これについては後で説明します。最初に、スライスを使用してプログラミングするときにスライスヘッダーの存在が何を意味するかを見てみましょう。</p>
</div>
<div class="section" id="id4">
<h2>スライスを関数に渡す<a class="headerlink" href="#id4" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスにポインターが含まれていても、それ自体が値であることを理解することが重要です。背後では、ポインターと長さを保持する構造体の値です。構造体へのポインタでは <em>ありません</em> 。</p>
<p>これは重要です。</p>
<p>前の例で <code class="docutils literal notranslate"><span class="pre">IndexRune</span></code> を呼び出したときに、スライスヘッダーの <em>コピー</em> が渡されました。この動作には重要な影響があります。</p>
<p>以下のシンプルな関数について考えてみます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">AddOneToEachElement</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
                <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span><span class="o">++</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>その名前が示すとおり、スライスのインデックスを反復処理し(forの <code class="docutils literal notranslate"><span class="pre">range</span></code> ループを使用)、要素をインクリメントします。</p>
<p>動かしてみましょう。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">slice</span> <span class="o">:=</span> <span class="nx">buffer</span><span class="p">[</span><span class="mi">10</span><span class="p">:</span><span class="mi">20</span><span class="p">]</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">);</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nb">byte</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;before&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">AddOneToEachElement</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;after&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(気になる場合は、これらの実行可能なスニペットを編集および再実行できます。)</p>
<p>スライス <em>ヘッダー</em> は値で渡されますが、ヘッダーには配列の要素へのポインターが含まれるため、元のスライスヘッダーと関数に渡されるヘッダーのコピーの両方が同じ配列を記述します。したがって、関数が戻ると、変更された要素は元のスライス変数を通して見ることができます。</p>
<p>この例のように、関数の引数は実際にはコピーです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">SubtractOneFromLength</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">byte</span> <span class="p">{</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Before: len(slice) =&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
        <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nx">SubtractOneFromLength</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;After:  len(slice) =&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;After:  len(newSlice) =&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここでは、関数によってスライス引数の <em>内容</em> を変更できますが、 <em>ヘッダー</em> は変更できないことがわかります。<code class="docutils literal notranslate"><span class="pre">slice</span></code> 変数に格納されている長さは、関数の呼び出しによって変更されません。これは、関数には元ではなくスライスヘッダーのコピーが渡されるためです。したがって、ヘッダーを変更する関数を作成する場合は、ここで行ったように、結果パラメーターとして返す必要があります。<code class="docutils literal notranslate"><span class="pre">slice</span></code> 変数は変更されていませんが、返される値の長さは新しいため <code class="docutils literal notranslate"><span class="pre">newSlice</span></code> に保存されます。</p>
</div>
<div class="section" id="id5">
<h2>スライスへのポインタ: メソッドのレシーバ<a class="headerlink" href="#id5" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>関数にスライスヘッダーを変更させる別の方法は、関数にポインターを渡すことです。これを行う前の例を少し変えた例を示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">PtrSubtractOneFromLength</span><span class="p">(</span><span class="nx">slicePtr</span> <span class="o">*</span><span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">slice</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">slicePtr</span>
        <span class="o">*</span><span class="nx">slicePtr</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Before: len(slice) =&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
        <span class="nx">PtrSubtractOneFromLength</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">slice</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;After:  len(slice) =&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上記の例では、特に余計な間接参照のレベルを扱う場合(一時的な変数が役たちます)ぎこちないように見えます。しかしスライスへのポインターを見かける一般的なケースが1つあります。スライスを変更するメソッドにポインターレシーバーを使用するのが慣用的です。</p>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">課題</p>
<p>訳がわからない</p>
<p>It seems clumsy in that example, especially dealing with the extra level of indirection (a temporary variable helps)</p>
<p>上記の例では、特に余計な間接参照のレベルを扱う場合(一時的な変数が役たちます)ぎこちないように見えます。</p>
</div>
<p>最後のスラッシュで切り捨てるメソッドをスライスに持たせたいとしましょう。次のように書くことができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">path</span><span class="p">)</span> <span class="nx">TruncateAtFinalSlash</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">i</span> <span class="o">:=</span> <span class="nx">bytes</span><span class="p">.</span><span class="nx">LastIndex</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="nx">i</span><span class="p">]</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">pathName</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">(</span><span class="s">&quot;/usr/bin/tso&quot;</span><span class="p">)</span> <span class="c1">// Conversion from string to path.</span>
        <span class="nx">pathName</span><span class="p">.</span><span class="nx">TruncateAtFinalSlash</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">pathName</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この例を実行すると、正しく動作し、呼び出し元のスライスを更新することがわかります。</p>
<p>[演習：レシーバーの型をポインターではなく値に変更して、再度実行します。何が起こるかを説明してください。]</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>[訳注] レシーバの型を値にすると、呼び出したときにスライスのコピーが渡されます。関数内でスライスを切り出して別のスライスを作成したとしても <code class="docutils literal notranslate"><span class="pre">pathName</span></code> には影響がありません。</p>
</div>
<p>一方、パス内のASCII文字を大文字にする(英語以外の名前を無視することで) <code class="docutils literal notranslate"><span class="pre">path</span></code> のメソッドを作成する場合、値のレシーバーは同じ基になる配列を指すため、メソッドは値になる可能性があります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="nx">path</span><span class="p">)</span> <span class="nx">ToUpper</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">p</span> <span class="p">{</span>
                <span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="p">{</span>
                        <span class="nx">p</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">pathName</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">(</span><span class="s">&quot;/usr/bin/tso&quot;</span><span class="p">)</span>
        <span class="nx">pathName</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">pathName</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで <code class="docutils literal notranslate"><span class="pre">ToUpper</span></code> メソッドは、<code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="docutils literal notranslate"><span class="pre">range</span></code> 構造内の2つの変数を使用して、インデックスとスライス要素をキャプチャします。この形式のループは、内で複数回 <code class="docutils literal notranslate"><span class="pre">p[i]</span></code> を書き込むことを避けます。</p>
<p>[演習：<code class="docutils literal notranslate"><span class="pre">ToUpper</span></code> メソッドを変換してポインターレシーバーを使用し、その動作が変化するかどうかを確認します。]</p>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>レシーバに値を渡してもポインタを渡しても動作に変化はありません。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">path</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">p</span> <span class="o">*</span><span class="nx">path</span><span class="p">)</span> <span class="nx">ToUpper</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">b</span> <span class="o">:=</span> <span class="k">range</span> <span class="o">*</span><span class="nx">p</span> <span class="p">{</span>
                <span class="k">if</span> <span class="sc">&#39;a&#39;</span> <span class="o">&lt;=</span> <span class="nx">b</span> <span class="o">&amp;&amp;</span> <span class="nx">b</span> <span class="o">&lt;=</span> <span class="sc">&#39;z&#39;</span> <span class="p">{</span>
                        <span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">b</span> <span class="o">+</span> <span class="sc">&#39;A&#39;</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
                <span class="p">}</span>
        <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">pathName</span> <span class="o">:=</span> <span class="nx">path</span><span class="p">(</span><span class="s">&quot;/usr/bin/tso&quot;</span><span class="p">)</span>
        <span class="nx">pathName</span><span class="p">.</span><span class="nx">ToUpper</span><span class="p">()</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;%s\n&quot;</span><span class="p">,</span> <span class="nx">pathName</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">/</span><span class="n">USR</span><span class="o">/</span><span class="n">BIN</span><span class="o">/</span><span class="n">TSO</span>

<span class="n">Program</span> <span class="n">exited</span><span class="o">.</span>
</pre></div>
</div>
</div>
<p>[高度な演習：<code class="docutils literal notranslate"><span class="pre">ToUpper</span></code> メソッドを変換して、ASCIIだけでなくUnicode文字を処理します。]</p>
</div>
<div class="section" id="capacity">
<h2>容量(Capacity)<a class="headerlink" href="#capacity" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p><code class="docutils literal notranslate"><span class="pre">ints</span></code> の引数スライスを1つの要素だけ拡張する次の関数を見てください。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">element</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">slice</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">element</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>(変更されたスライスを返す必要があるのはなぜですか？)それを実行します：</p>
<p>(Why does it need to return the modified slice?) Now run it:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">iBuffer</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span>
        <span class="nx">slice</span> <span class="o">:=</span> <span class="nx">iBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">20</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                <span class="nx">slice</span> <span class="p">=</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
                <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>スライスがどのように成長するかを確認してください...。最後までは成長しません。</p>
<p>スライスヘッダーの3番目のコンポーネントである容量について説明します。配列へのポインタと長さに加えて、スライスヘッダーにはその <em>容量</em> も格納されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">type</span> <span class="nx">sliceHeader</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">Length</span>        <span class="kt">int</span>
        <span class="nx">Capacity</span>      <span class="kt">int</span>
        <span class="nx">ZerothElement</span> <span class="o">*</span><span class="kt">byte</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Capacity</span></code> フィールドには、基になる配列に実際にどのくらいのスペースがあるかが記録されます。これは <code class="docutils literal notranslate"><span class="pre">Length</span></code> が到達できる最大値です。スライスをその容量を超えて拡大しようとすると、配列の制限を超えてパニックを引き起こします。</p>
<p>以下のように、サンプルスライスが作成された後</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">iBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>そのヘッダーは次のようになります。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nx">sliceHeader</span><span class="p">{</span>
        <span class="nx">Length</span><span class="p">:</span>        <span class="mi">0</span><span class="p">,</span>
        <span class="nx">Capacity</span><span class="p">:</span>      <span class="mi">10</span><span class="p">,</span>
        <span class="nx">ZerothElement</span><span class="p">:</span> <span class="o">&amp;</span><span class="nx">iBuffer</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Capacity</span></code> フィールドは、基となる配列の長さから、スライスの最初の要素の配列のインデックス(この場合は0)を引いた値に等しくなります。スライスの容量を確認する場合は、組み込みの関数の <code class="docutils literal notranslate"><span class="pre">cap</span></code> を使用します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;slice is full!&quot;</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="make">
<h2>Make<a class="headerlink" href="#make" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスをその容量を超えて成長させたい場合はどうなりますか？できません！定義上、容量は成長の限界です。ただし、新しい配列を割り当て、データをコピーし、スライスを変更して新しい配列を記述することにより、同等の結果を得ることができます。</p>
<p>割り当てから始めましょう。組み込み関数 <code class="docutils literal notranslate"><span class="pre">new</span></code> を使用してより大きな配列を割り当て、結果をスライスできますが、代わりに <code class="docutils literal notranslate"><span class="pre">make</span></code> 組み込み関数を使用する方が簡単です。新しい配列を割り当て、それを記述するスライスヘッダーを一度に作成します。<code class="docutils literal notranslate"><span class="pre">make</span></code> 関数は、3つの引数を取ります。スライスの型、その初期の長さ、およびその容量(スライスデータを保持するために <code class="docutils literal notranslate"><span class="pre">make</span></code> が割り当てる配列の長さ)です。この呼び出しは、実行するとわかるように、長さ10のスライスを作成し、さらに5つ(15-10)分のスペースを確保します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;len: %d, cap: %d\n&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</pre></div>
</div>
<p>以下のスニペットは <code class="docutils literal notranslate"><span class="pre">int</span></code> スライスの容量を2倍にしますが、長さは同じままです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;len: %d, cap: %d\n&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
<span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
        <span class="nx">newSlice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
<span class="p">}</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;len: %d, cap: %d\n&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
</pre></div>
</div>
<p>このコードを実行した後、スライスは、別の再割り当てを必要とする前に拡大する余地がはるかにあります。</p>
<p>スライスを作成するとき、長さと容量が同じになることがよくあります。<code class="docutils literal notranslate"><span class="pre">make</span></code> 組み込み関数には、この一般的なケースの省略形があります。容量はデフォルトで長さ引数と同じ値が設定されているため、省略して、両方を同じ値に設定できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">gophers</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="nx">Gopher</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">gophers</span></code> スライスの長さと容量の両方が10に設定されています。</p>
</div>
<div class="section" id="copy">
<h2>Copy<a class="headerlink" href="#copy" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>前のセクションでスライスの容量を2倍にしたとき、古いデータを新しいスライスにコピーするループを作成しました。Goには、これを簡単にするための組み込み関数 <code class="docutils literal notranslate"><span class="pre">copy</span></code> があります。引数は2つのスライスであり、データを右側の引数から左側の引数にコピーします。コピーを使用するように書き直した例を次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">))</span>
<span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> 関数はスマートです。両方の引数の長さに注意を払いながら、できることだけをコピーします。つまり、コピーする要素の数は、2つのスライスの長さの最小値です。これにより、実装が少しだけ簡略化されます。また <code class="docutils literal notranslate"><span class="pre">copy</span></code> は、コピーした要素の数である整数値を返しますが、常にチェックする必要はありません。</p>
<p><code class="docutils literal notranslate"><span class="pre">copy</span></code> 関数は、コピー元とコピー先の要素が重なるときにも適切に機能します。つまり、単一のスライス内でアイテムをシフトするために使用できます。<code class="docutils literal notranslate"><span class="pre">copy</span></code> を使用して、スライスの中央に値を挿入する方法を次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Insert inserts the value into the slice at the specified index,</span>
<span class="c1">// which must be in range.</span>
<span class="c1">// The slice must have room for the new element.</span>
<span class="kd">func</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">index</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="c1">// Grow the slice by one element.</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">// Use copy to move the upper part of the slice out of the way and open a hole.</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">:])</span>
        <span class="c1">// Store the new value.</span>
        <span class="nx">slice</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="p">=</span> <span class="nx">value</span>
        <span class="c1">// Return the result.</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この関数には、注意すべき点がいくつかあります。もちろん、最初に、長さが変更されているため、更新されたスライスを返す必要があります。第二に、便利な略記法を使用します。以下は</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">:]</span>
</pre></div>
</div>
<p>とまったく同じ意味です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)]</span>
</pre></div>
</div>
<p>また、このトリックはまだ使用していませんが、スライス式の最初の要素も省略できます。デフォルトは0です。よって</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span><span class="p">[:]</span>
</pre></div>
</div>
<p>スライス自体を意味するだけで、配列をスライスするときに便利です。この式は「配列のすべての要素を記述するスライス」と言う最も簡単な方法です。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">array</span><span class="p">[:]</span>
</pre></div>
</div>
<p>これで作業は完了です。<code class="docutils literal notranslate"><span class="pre">Insert</span></code> 関数を実行しましょう。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span> <span class="c1">// Note capacity &gt; length: room to add element.</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">slice</span> <span class="p">{</span>
        <span class="nx">slice</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">i</span>
<span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nx">Insert</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">99</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>[訳注]: 以下の結果を得ることができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">99</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>

<span class="n">Program</span> <span class="n">exited</span><span class="o">.</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="append">
<h2>Append: 例<a class="headerlink" href="#append" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>数セクション前に、1つの要素でスライスを拡張する <code class="docutils literal notranslate"><span class="pre">Extend</span></code> 関数を作成しました。 ただし、スライスの容量が小さすぎると機能がクラッシュするため、バグがありました。(<code class="docutils literal notranslate"><span class="pre">Insert</span></code> の例にも同じ問題があります。)これを修正するための準備が整ったので、整数スライス用の <code class="docutils literal notranslate"><span class="pre">Extend</span></code> の堅牢な実装を作成しましょう。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">element</span> <span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Slice is full; must grow.</span>
                <span class="c1">// We double its size and add 1, so if the size is zero we still grow.</span>
                <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
                <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
        <span class="p">}</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nx">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="nx">slice</span><span class="p">[</span><span class="nx">n</span><span class="p">]</span> <span class="p">=</span> <span class="nx">element</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>この場合、スライスを返すことが特に重要です。スライスを再割り当てすると、結果のスライスが完全に異なる配列を記述するためです。スライスがいっぱいになったときに何が起こるかを示すための小さなスニペットを次に示します。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;len=%d cap=%d slice=%v\n&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">),</span> <span class="nx">slice</span><span class="p">)</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;address of 0th element:&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>[訳注]: 以下の結果を得ることができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="o">=</span><span class="mi">1</span> <span class="n">cap</span><span class="o">=</span><span class="mi">5</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x456000</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">2</span> <span class="n">cap</span><span class="o">=</span><span class="mi">5</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x456000</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">3</span> <span class="n">cap</span><span class="o">=</span><span class="mi">5</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x456000</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">4</span> <span class="n">cap</span><span class="o">=</span><span class="mi">5</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x456000</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">5</span> <span class="n">cap</span><span class="o">=</span><span class="mi">5</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x456000</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">6</span> <span class="n">cap</span><span class="o">=</span><span class="mi">11</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x454030</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">7</span> <span class="n">cap</span><span class="o">=</span><span class="mi">11</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x454030</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">8</span> <span class="n">cap</span><span class="o">=</span><span class="mi">11</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x454030</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">9</span> <span class="n">cap</span><span class="o">=</span><span class="mi">11</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x454030</span>
<span class="nb">len</span><span class="o">=</span><span class="mi">10</span> <span class="n">cap</span><span class="o">=</span><span class="mi">11</span> <span class="nb">slice</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="mi">7</span> <span class="mi">8</span> <span class="mi">9</span><span class="p">]</span>
<span class="n">address</span> <span class="n">of</span> <span class="mi">0</span><span class="n">th</span> <span class="n">element</span><span class="p">:</span> <span class="mh">0x454030</span>

<span class="n">Program</span> <span class="n">exited</span><span class="o">.</span>
</pre></div>
</div>
</div>
<p>サイズ5の初期配列がいっぱいになると、再割り当てに注意してください。新しい配列が割り当てられると、0番目の要素の容量とアドレスが変更されます。</p>
<p>堅牢な <code class="docutils literal notranslate"><span class="pre">Extend</span></code> 関数をガイドとして使用すると、スライスを複数の要素で拡張できるさらに優れた関数を作成できます。 これを行うには、関数の呼び出し時に関数の引数のリストをスライスに変換するGoの機能を使用します。つまり、Goの可変機能機能を使用します。</p>
<p>関数 <code class="docutils literal notranslate"><span class="pre">Append</span></code> を呼び出しましょう。最初のバージョンでは <code class="docutils literal notranslate"><span class="pre">Extend</span></code> を繰り返し呼び出すだけで、可変引数関数のメカニズムが明確になります。追加したシグネチャは次のとおりです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">items</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span>
</pre></div>
</div>
<p>つまり <code class="docutils literal notranslate"><span class="pre">Append</span></code> は1つの引数(スライス)の後に0個以上の <code class="docutils literal notranslate"><span class="pre">int</span></code> の引数が続くということです。これらの引数は、次のように <code class="docutils literal notranslate"><span class="pre">Append</span></code> の実装に関する限り、<code class="docutils literal notranslate"><span class="pre">int</span></code> のスライスです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Append appends the items to the slice.</span>
<span class="c1">// First version: just loop calling Extend.</span>
<span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">items</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">item</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
                <span class="nx">slice</span> <span class="p">=</span> <span class="nx">Extend</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">item</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">for</span></code> <code class="docutils literal notranslate"><span class="pre">range</span></code> のループが <code class="docutils literal notranslate"><span class="pre">items</span></code> 引数の要素を反復処理していることに注目してください。これは型 <code class="docutils literal notranslate"><span class="pre">[]int</span></code> を暗黙的に示しています。また、ループ内のインデックスを破棄するために空白の識別子 <code class="docutils literal notranslate"><span class="pre">_</span></code> を使用していることに注意してください。この場合はインデックスは必要ありません。</p>
<p>Try it:</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
</pre></div>
</div>
<p>この例のもう1つの新しいテクニックは、複合リテラルを記述することによってスライスを初期化することです。複合リテラルは、スライスのタイプとそれに続く括弧で囲まれた要素で構成されます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Append</span></code> 機能は、別の理由で興味深いものです。要素を追加できるだけでなく、呼び出し側で <code class="docutils literal notranslate"><span class="pre">...</span></code> 表記を使用して、スライスを引数に「展開」することにより、2番目のスライス全体を追加できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">slice2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">)</span>
<span class="nx">slice1</span> <span class="p">=</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice1</span><span class="p">,</span> <span class="nx">slice2</span><span class="o">...</span><span class="p">)</span> <span class="c1">// The &#39;...&#39; is essential!</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">)</span>
</pre></div>
</div>
<p>もちろん <code class="docutils literal notranslate"><span class="pre">Extend</span></code> の内部に基づいて複数回割り当てることで、<code class="docutils literal notranslate"><span class="pre">Append</span></code> をより効率的にすることができます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Append appends the elements to the slice.</span>
<span class="c1">// Efficient version.</span>
<span class="kd">func</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice</span> <span class="p">[]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">elements</span> <span class="o">...</span><span class="kt">int</span><span class="p">)</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">{</span>
        <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
        <span class="nx">total</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nx">elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="nx">total</span> <span class="p">&gt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// Reallocate. Grow to 1.5 times the new size, so we can still grow.</span>
                <span class="nx">newSize</span> <span class="o">:=</span> <span class="nx">total</span><span class="o">*</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="nx">newSlice</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="nx">total</span><span class="p">,</span> <span class="nx">newSize</span><span class="p">)</span>
                <span class="nb">copy</span><span class="p">(</span><span class="nx">newSlice</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
                <span class="nx">slice</span> <span class="p">=</span> <span class="nx">newSlice</span>
        <span class="p">}</span>
        <span class="nx">slice</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[:</span><span class="nx">total</span><span class="p">]</span>
        <span class="nb">copy</span><span class="p">(</span><span class="nx">slice</span><span class="p">[</span><span class="nx">n</span><span class="p">:],</span> <span class="nx">elements</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">slice</span>
<span class="p">}</span>
</pre></div>
</div>
<p>ここで、<code class="docutils literal notranslate"><span class="pre">copy</span></code> を2回使用する方法に注意してください。1回はスライスデータを新しく割り当てられたメモリに移動し、その後、追加するデータを古いデータの最後にコピーします。</p>
<p>以下を試してみてください;動作は以前と同じです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
<span class="nx">slice2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">)</span>
<span class="nx">slice1</span> <span class="p">=</span> <span class="nx">Append</span><span class="p">(</span><span class="nx">slice1</span><span class="p">,</span> <span class="nx">slice2</span><span class="o">...</span><span class="p">)</span> <span class="c1">// The &#39;...&#39; is essential!</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">slice1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h2>Append: 組み込み関数<a class="headerlink" href="#id7" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>それで、<code class="docutils literal notranslate"><span class="pre">append</span></code> 組み込み関数の設計の動機に到達します。<code class="docutils literal notranslate"><span class="pre">Append</span></code> の例と同等の効率で正確に機能しますが、どのスライス型でも機能します。</p>
<p>Goの弱点は、ジェネリック型の操作を実行時に提供する必要があることです。いつか変わる可能性がありますが、現時点では、スライスの操作を簡単にするために、Goには組み込みの汎用 <code class="docutils literal notranslate"><span class="pre">append</span></code> 関数が用意されています。<code class="docutils literal notranslate"><span class="pre">int</span></code> スライスバージョンと同じように機能しますが <strong>すべて</strong> のスライス型に対して機能します。</p>
<p>スライスヘッダーは <code class="docutils literal notranslate"><span class="pre">append</span></code> の呼び出しによって常に更新されるため、呼び出し後に返されたスライスを保存する必要があることに注意してください。実際、コンパイラーは結果を保存せずに <code class="docutils literal notranslate"><span class="pre">append</span></code> を呼び出すことはできません。</p>
<p>以下は、printステートメントと混ざったワンライナーです。それらを試して編集し、探索してください：</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create a couple of starter slices.</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
<span class="nx">slice2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">55</span><span class="p">,</span> <span class="mi">66</span><span class="p">,</span> <span class="mi">77</span><span class="p">}</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Start slice: &quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Start slice2:&quot;</span><span class="p">,</span> <span class="nx">slice2</span><span class="p">)</span>

<span class="c1">// Add an item to a slice.</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Add one item:&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>

<span class="c1">// Add one slice to another.</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">slice2</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Add one slice:&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>

<span class="c1">// Make a copy of a slice (of int).</span>
<span class="nx">slice3</span> <span class="o">:=</span> <span class="nb">append</span><span class="p">([]</span><span class="nb">int</span><span class="p">(</span><span class="kc">nil</span><span class="p">),</span> <span class="nx">slice</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Copy a slice:&quot;</span><span class="p">,</span> <span class="nx">slice3</span><span class="p">)</span>

<span class="c1">// Copy a slice to the end of itself.</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Before append to self:&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="nx">slice</span><span class="o">...</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;After append to self:&quot;</span><span class="p">,</span> <span class="nx">slice</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">注釈</p>
<p>[訳注]: 以下の結果を得ることができます。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Start</span> <span class="nb">slice</span><span class="p">:</span>  <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">]</span>
<span class="n">Start</span> <span class="n">slice2</span><span class="p">:</span> <span class="p">[</span><span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span><span class="p">]</span>
<span class="n">Add</span> <span class="n">one</span> <span class="n">item</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">Add</span> <span class="n">one</span> <span class="nb">slice</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span><span class="p">]</span>
<span class="n">Copy</span> <span class="n">a</span> <span class="nb">slice</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span><span class="p">]</span>
<span class="n">Before</span> <span class="n">append</span> <span class="n">to</span> <span class="bp">self</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span><span class="p">]</span>
<span class="n">After</span> <span class="n">append</span> <span class="n">to</span> <span class="bp">self</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">55</span> <span class="mi">66</span> <span class="mi">77</span><span class="p">]</span>

<span class="n">Program</span> <span class="n">exited</span><span class="o">.</span>
</pre></div>
</div>
</div>
<p>スライスの設計によってこの単純な呼び出しが正しく機能することを可能にする方法を理解するために、その例の最後のワンライナーについて詳しく考える時間をとる価値があります。</p>
<p>コミュニティが構築した「 <a class="reference external" href="https://golang.org/wiki/SliceTricks">Slice Trickes</a> 」Wikiページには、スライスの <code class="docutils literal notranslate"><span class="pre">append</span></code>、<code class="docutils literal notranslate"><span class="pre">copy</span></code> 、およびその他の使用方法の例が他にもたくさんあります。</p>
<ul class="simple">
<li><p>Nil</p></li>
</ul>
<hr class="docutils" />
<p>余談ですが、私たちの新たな知見により <code class="docutils literal notranslate"><span class="pre">nil</span></code> スライスの表現が何であるかを見ることができます。当然、スライスヘッダーの値はゼロです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sliceHeader</span><span class="p">{</span>
        <span class="nx">Length</span><span class="p">:</span>        <span class="mi">0</span><span class="p">,</span>
        <span class="nx">Capacity</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
        <span class="nx">ZerothElement</span><span class="p">:</span> <span class="kc">nil</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>
</div>
<p>あるいは単に</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">sliceHeader</span><span class="p">{}</span>
</pre></div>
</div>
<p>重要な詳細は、配列の要素へのポインタも <code class="docutils literal notranslate"><span class="pre">nil</span></code> であることです。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>上記によって作成されたスライスは長さ0(および場合によっては容量0)がありますが、そのポインターは <code class="docutils literal notranslate"><span class="pre">nil</span></code> ではないため、nilスライスではありません。</p>
<p>明らかなように、空のスライスは大きくなる可能性があります(容量がゼロでないと仮定します)が、<code class="docutils literal notranslate"><span class="pre">nil</span></code> スライスには値を入れる配列がなく、1つの要素を保持するために大きくなることはありません。</p>
<p>つまり <code class="docutils literal notranslate"><span class="pre">nil</span></code> スライスは、要素へのポインタを保持していない場合でも、機能的に長さが0のスライスと同等です。 長さは0で、割り当てて追加できます。 例として、<code class="docutils literal notranslate"><span class="pre">nil</span></code> スライスに追加してスライスをコピーする上記の1行のライナーを見てください。</p>
<ul class="simple">
<li><p>文字列(Strings)</p></li>
</ul>
<hr class="docutils" />
<p>スライスのコンテキストにおけるGoの文字列に関する簡単なセクションです。</p>
<p>文字列は実際には非常に単純です。文字列は読み取り専用のバイトスライスであり、言語からの余分な構文サポートが少しあります。</p>
<p>これらは読み取り専用であるため、容量は必要ありません(容量を増やすことはできません)が、それ以外の場合はほとんどの目的で、読み取り専用のバイトスライスのように扱うことができます。</p>
<p>まず、個々のバイトにアクセスするためにインデックスを作成できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slash</span> <span class="o">:=</span> <span class="s">&quot;/usr/ken&quot;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// yields the byte value &#39;/&#39;.</span>
</pre></div>
</div>
<p>文字列をスライスして部分文字列を取得できます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">usr</span> <span class="o">:=</span> <span class="s">&quot;/usr/ken&quot;</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="c1">// yields the string &quot;/usr&quot;</span>
</pre></div>
</div>
<p>これで、文字列をスライスしたときに裏で何が起こっているかが明らかになります。</p>
<p>通常のバイトスライスを取得し、単純な変換を使用して、そこから文字列を作成することもできます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">str</span> <span class="o">:=</span> <span class="nb">string</span><span class="p">(</span><span class="nx">slice</span><span class="p">)</span>
</pre></div>
</div>
<p>そして逆のこともできます。</p>
<div class="highlight-go notranslate"><div class="highlight"><pre><span></span><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">usr</span><span class="p">)</span>
</pre></div>
</div>
<p>文字列の基になる配列はビューから隠されています。stringを使用しない限り、そのコンテンツにアクセスする方法はありません。つまり、これらの変換のいずれかを行う場合、配列のコピーを作成する必要があります。もちろん、Goがこれを処理するので、必要はありません。これらの変換のいずれかの後、バイトスライスの基になる配列への変更は、対応する文字列に影響しません。</p>
<p>この文字列のスライスのような設計の重要な結果は、部分文字列の作成が非常に効率的であることです。発生する必要があるのは、2ワードの文字列ヘッダーを作成することだけです。文字列は読み取り専用であるため、元の文字列とスライス操作の結果の文字列は同じ配列を安全に共有できます。</p>
<p>歴史的なメモ：文字列の初期実装は常に割り当てられますが、言語にスライスが追加されると、文字列を効率的に処理するためのモデルが提供されました。一部のベンチマークでは、結果として大幅な高速化が見られました。</p>
<p>もちろん、文字列にはさらに多くのものがあり、<a class="reference external" href="https://blog.golang.org/strings">別のブログ投稿</a> で文字列の詳細を説明しています。</p>
</div>
<div class="section" id="id9">
<h2>結論<a class="headerlink" href="#id9" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>スライスの仕組みを理解するには、スライスの実装方法を理解することが役立ちます。スライスヘッダーという小さなデータ構造があります。これは、スライス変数に関連付けられたアイテムです。このヘッダーは、個別に割り当てられた配列のセクションを記述します。 スライス値を渡すと、ヘッダーがコピーされますが、ヘッダーが指す配列は常に共有されます。</p>
<p>スライスがどのように機能するかを理解すると、スライスは使いやすくなるだけでなく、特に組み込み関数の <code class="docutils literal notranslate"><span class="pre">copy</span></code> と <code class="docutils literal notranslate"><span class="pre">append</span></code> の助けを借りて、強力で表現力豊かになります。</p>
</div>
<div class="section" id="id10">
<h2>さらに読むために<a class="headerlink" href="#id10" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>Goのスライスに関するintertubesの周りには、たくさんの発見があります。 前述のように、「 <a class="reference external" href="https://golang.org/wiki/SliceTricks">Slice Trickes</a> 」Wikiページには多くの例があります。 <a class="reference external" href="https://blog.golang.org/go-slices-usage-and-internals">Go Slices</a> のブログ投稿では、メモリレイアウトの詳細をわかりやすい図で説明しています。 Russ Coxの <a class="reference external" href="https://research.swtch.com/godata">Go Data Structures</a> の記事には、Goの他の内部データ構造の一部とともにスライスの説明が含まれています。</p>
<div class="admonition-todo admonition" id="id12">
<p class="admonition-title">課題</p>
<p>intertubes の意味がわからない</p>
</div>
<p>より多くの資料が利用可能ですが、スライスについて学ぶ最良の方法はそれらを使用することです。</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div id="toc" class="sidebarRow">
    <h5><a href="index.html">The Go Blog</a></h5>
    <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="context.html">Go Concurrency Patterns: Context</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Arrays, slices (and strings): The mechanics of 'append'</a></li>
<li class="toctree-l1"><a class="reference internal" href="slices_usage_and_internals.html">Go Slices: usage and internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="Error_handling_and_Go.html">Error handling and Go</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="todo.html">TODO(内部用)</a></li>
</ul>

    
</div>

<style type="text/css">
    .toctree-l1 {
        font-size: 12px;
        margin-bottom: 0;
        font-stretch: normal;
        font-style: normal;
        line-height: 1.33;
        padding-bottom: 5px;
        margin: 2px;
    }
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;VividCortex (translated by @d-tsuji).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/slices.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>