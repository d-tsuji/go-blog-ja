
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>&lt;no title&gt; &#8212; Go database/sql tutorial  ドキュメント</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/translations.js"></script>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <a href="https://github.com/d-tsuji/go-introduction-book"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a><p>Go's slice type provides a convenient and efficient means of working
with sequences of typed data. Slices are analogous to arrays in other
languages, but have some unusual properties. This article will look at
what slices are and how they are used.</p>
<p><strong>Arrays</strong></p>
<p>The slice type is an abstraction built on top of Go's array type, and so
to understand slices we must first understand arrays.</p>
<p>An array type definition specifies a length and an element type. For
example, the type <code class="docutils literal notranslate"><span class="pre">[4]int</span></code> represents an array of four integers. An
array's size is fixed; its length is part of its type (<code class="docutils literal notranslate"><span class="pre">[4]int</span></code> and
<code class="docutils literal notranslate"><span class="pre">[5]int</span></code> are distinct, incompatible types). Arrays can be indexed in
the usual way, so the expression <code class="docutils literal notranslate"><span class="pre">s[n]</span></code> accesses the <em>n</em>th element,
starting from zero.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">a</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="nb">int</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">//</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Arrays do not need to be initialized explicitly; the zero value of an
array is a ready-to-use array whose elements are themselves zeroed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">the</span> <span class="n">zero</span> <span class="n">value</span> <span class="n">of</span> <span class="n">the</span> <span class="nb">int</span> <span class="nb">type</span>
</pre></div>
</div>
<p>The in-memory representation of <code class="docutils literal notranslate"><span class="pre">[4]int</span></code> is just four integer values
laid out sequentially:</p>
<p><img alt="image0" src="slice-array.png" /></p>
<p>Go's arrays are values. An array variable denotes the entire array; it
is not a pointer to the first array element (as would be the case in C).
This means that when you assign or pass around an array value you will
make a copy of its contents. (To avoid the copy you could pass a
<em>pointer</em> to the array, but then that's a pointer to an array, not an
array.) One way to think about arrays is as a sort of struct but with
indexed rather than named fields: a fixed-size composite value.</p>
<p>An array literal can be specified like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;Penn&quot;</span><span class="p">,</span> <span class="s2">&quot;Teller&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>Or, you can have the compiler count the array elements for you:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;Penn&quot;</span><span class="p">,</span> <span class="s2">&quot;Teller&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>In both cases, the type of <code class="docutils literal notranslate"><span class="pre">b</span></code> is <code class="docutils literal notranslate"><span class="pre">[2]string</span></code>.</p>
<p><strong>Slices</strong></p>
<p>Arrays have their place, but they're a bit inflexible, so you don't see
them too often in Go code. Slices, though, are everywhere. They build on
arrays to provide great power and convenience.</p>
<p>The type specification for a slice is <code class="docutils literal notranslate"><span class="pre">[]T</span></code>, where <code class="docutils literal notranslate"><span class="pre">T</span></code> is the type
of the elements of the slice. Unlike an array type, a slice type has no
specified length.</p>
<p>A slice literal is declared just like an array literal, except you leave
out the element count:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">letters</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>A slice can be created with the built-in function called <code class="docutils literal notranslate"><span class="pre">make</span></code>, which
has the signature,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">make</span><span class="p">([]</span><span class="n">T</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="n">cap</span><span class="p">)</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
<p>where T stands for the element type of the slice to be created. The
<code class="docutils literal notranslate"><span class="pre">make</span></code> function takes a type, a length, and an optional capacity. When
called, <code class="docutils literal notranslate"><span class="pre">make</span></code> allocates an array and returns a slice that refers to
that array.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">s</span> <span class="p">[]</span><span class="n">byte</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">//</span> <span class="n">s</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
</pre></div>
</div>
<p>When the capacity argument is omitted, it defaults to the specified
length. Here's a more succinct version of the same code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>The length and capacity of a slice can be inspected using the built-in
<code class="docutils literal notranslate"><span class="pre">len</span></code> and <code class="docutils literal notranslate"><span class="pre">cap</span></code> functions.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
<span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span>
</pre></div>
</div>
<p>The next two sections discuss the relationship between length and
capacity.</p>
<p>The zero value of a slice is <code class="docutils literal notranslate"><span class="pre">nil</span></code>. The <code class="docutils literal notranslate"><span class="pre">len</span></code> and <code class="docutils literal notranslate"><span class="pre">cap</span></code> functions
will both return 0 for a nil slice.</p>
<p>A slice can also be formed by &quot;slicing&quot; an existing slice or array.
Slicing is done by specifying a half-open range with two indices
separated by a colon. For example, the expression <code class="docutils literal notranslate"><span class="pre">b[1:4]</span></code> creates a
slice including elements 1 through 3 of <code class="docutils literal notranslate"><span class="pre">b</span></code> (the indices of the
resulting slice will be 0 through 2).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">}</span>
<span class="o">//</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">},</span> <span class="n">sharing</span> <span class="n">the</span> <span class="n">same</span> <span class="n">storage</span> <span class="k">as</span> <span class="n">b</span>
</pre></div>
</div>
<p>The start and end indices of a slice expression are optional; they
default to zero and the slice's length respectively:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">//</span> <span class="n">b</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">}</span>
<span class="o">//</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;l&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">}</span>
<span class="o">//</span> <span class="n">b</span><span class="p">[:]</span> <span class="o">==</span> <span class="n">b</span>
</pre></div>
</div>
<p>This is also the syntax to create a slice given an array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="p">:</span><span class="o">=</span> <span class="n">x</span><span class="p">[:]</span> <span class="o">//</span> <span class="n">a</span> <span class="nb">slice</span> <span class="n">referencing</span> <span class="n">the</span> <span class="n">storage</span> <span class="n">of</span> <span class="n">x</span>
</pre></div>
</div>
<p><strong>Slice internals</strong></p>
<p>A slice is a descriptor of an array segment. It consists of a pointer to
the array, the length of the segment, and its capacity (the maximum
length of the segment).</p>
<p><img alt="image1" src="slice-struct.png" /></p>
<p>Our variable <code class="docutils literal notranslate"><span class="pre">s</span></code>, created earlier by <code class="docutils literal notranslate"><span class="pre">make([]byte,</span> <span class="pre">5)</span></code>, is
structured like this:</p>
<p><img alt="image2" src="slice-1.png" /></p>
<p>The length is the number of elements referred to by the slice. The
capacity is the number of elements in the underlying array (beginning at
the element referred to by the slice pointer). The distinction between
length and capacity will be made clear as we walk through the next few
examples.</p>
<p>As we slice <code class="docutils literal notranslate"><span class="pre">s</span></code>, observe the changes in the slice data structure and
their relation to the underlying array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<p><img alt="image3" src="slice-2.png" /></p>
<p>Slicing does not copy the slice's data. It creates a new slice value
that points to the original array. This makes slice operations as
efficient as manipulating array indices. Therefore, modifying the
<em>elements</em> (not the slice itself) of a re-slice modifies the elements of
the original slice:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">d</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>
<span class="n">e</span> <span class="p">:</span><span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="o">//</span> <span class="n">e</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">}</span>
<span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
<span class="o">//</span> <span class="n">e</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">}</span>
<span class="o">//</span> <span class="n">d</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">}</span>
</pre></div>
</div>
<p>Earlier we sliced <code class="docutils literal notranslate"><span class="pre">s</span></code> to a length shorter than its capacity. We can
grow s to its capacity by slicing it again:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span>
</pre></div>
</div>
<p><img alt="image4" src="slice-3.png" /></p>
<p>A slice cannot be grown beyond its capacity. Attempting to do so will
cause a runtime panic, just as when indexing outside the bounds of a
slice or array. Similarly, slices cannot be re-sliced below zero to
access earlier elements in the array.</p>
<p><strong>Growing slices (the copy and append functions)</strong></p>
<p>To increase the capacity of a slice one must create a new, larger slice
and copy the contents of the original slice into it. This technique is
how dynamic array implementations from other languages work behind the
scenes. The next example doubles the capacity of <code class="docutils literal notranslate"><span class="pre">s</span></code> by making a new
slice, <code class="docutils literal notranslate"><span class="pre">t</span></code>, copying the contents of <code class="docutils literal notranslate"><span class="pre">s</span></code> into <code class="docutils literal notranslate"><span class="pre">t</span></code>, and then
assigning the slice value <code class="docutils literal notranslate"><span class="pre">t</span></code> to <code class="docutils literal notranslate"><span class="pre">s</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="o">+</span><span class="mi">1</span> <span class="ow">in</span> <span class="n">case</span> <span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>The looping piece of this common operation is made easier by the
built-in copy function. As the name suggests, copy copies data from a
source slice to a destination slice. It returns the number of elements
copied.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="nb">int</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">copy</span></code> function supports copying between slices of different
lengths (it will copy only up to the smaller number of elements). In
addition, <code class="docutils literal notranslate"><span class="pre">copy</span></code> can handle source and destination slices that share
the same underlying array, handling overlapping slices correctly.</p>
<p>Using <code class="docutils literal notranslate"><span class="pre">copy</span></code>, we can simplify the code snippet above:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="n">byte</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="p">(</span><span class="n">cap</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
<span class="n">copy</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">t</span>
</pre></div>
</div>
<p>A common operation is to append data to the end of a slice. This
function appends byte elements to a slice of bytes, growing the slice if
necessary, and returns the updated slice value:</p>
<p>{{code &quot;/doc/progs/slices.go&quot; `/AppendByte/` `/STOP/<a href="#id1"><span class="problematic" id="id2">`</span></a>}}</p>
<p>One could use <code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">AppendByte</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">)</span>
<span class="o">//</span> <span class="n">p</span> <span class="o">==</span> <span class="p">[]</span><span class="n">byte</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>
</pre></div>
</div>
<p>Functions like <code class="docutils literal notranslate"><span class="pre">AppendByte</span></code> are useful because they offer complete
control over the way the slice is grown. Depending on the
characteristics of the program, it may be desirable to allocate in
smaller or larger chunks, or to put a ceiling on the size of a
reallocation.</p>
<p>But most programs don't need complete control, so Go provides a built-in
<code class="docutils literal notranslate"><span class="pre">append</span></code> function that's good for most purposes; it has the signature</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">func</span> <span class="n">append</span><span class="p">(</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span> <span class="o">...</span><span class="n">T</span><span class="p">)</span> <span class="p">[]</span><span class="n">T</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">append</span></code> function appends the elements <code class="docutils literal notranslate"><span class="pre">x</span></code> to the end of the
slice <code class="docutils literal notranslate"><span class="pre">s</span></code>, and grows the slice if a greater capacity is needed.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">([]</span><span class="nb">int</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="o">//</span> <span class="n">a</span> <span class="o">==</span> <span class="p">[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">//</span> <span class="n">a</span> <span class="o">==</span> <span class="p">[]</span><span class="nb">int</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
</pre></div>
</div>
<p>To append one slice to another, use <code class="docutils literal notranslate"><span class="pre">...</span></code> to expand the second
argument to a list of arguments.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;John&quot;</span><span class="p">,</span> <span class="s2">&quot;Paul&quot;</span><span class="p">}</span>
<span class="n">b</span> <span class="p">:</span><span class="o">=</span> <span class="p">[]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;George&quot;</span><span class="p">,</span> <span class="s2">&quot;Ringo&quot;</span><span class="p">,</span> <span class="s2">&quot;Pete&quot;</span><span class="p">}</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">...</span><span class="p">)</span> <span class="o">//</span> <span class="n">equivalent</span> <span class="n">to</span> <span class="s2">&quot;append(a, b[0], b[1], b[2])&quot;</span>
<span class="o">//</span> <span class="n">a</span> <span class="o">==</span> <span class="p">[]</span><span class="n">string</span><span class="p">{</span><span class="s2">&quot;John&quot;</span><span class="p">,</span> <span class="s2">&quot;Paul&quot;</span><span class="p">,</span> <span class="s2">&quot;George&quot;</span><span class="p">,</span> <span class="s2">&quot;Ringo&quot;</span><span class="p">,</span> <span class="s2">&quot;Pete&quot;</span><span class="p">}</span>
</pre></div>
</div>
<p>Since the zero value of a slice (<code class="docutils literal notranslate"><span class="pre">nil</span></code>) acts like a zero-length slice,
you can declare a slice variable and then append to it in a loop:</p>
<p>{{code &quot;/doc/progs/slices.go&quot; `/Filter/` `/STOP/<a href="#id3"><span class="problematic" id="id4">`</span></a>}}</p>
<p><strong>A possible &quot;gotcha&quot;</strong></p>
<p>As mentioned earlier, re-slicing a slice doesn't make a copy of the
underlying array. The full array will be kept in memory until it is no
longer referenced. Occasionally this can cause the program to hold all
the data in memory when only a small piece of it is needed.</p>
<p>For example, this <code class="docutils literal notranslate"><span class="pre">FindDigits</span></code> function loads a file into memory and
searches it for the first group of consecutive numeric digits, returning
them as a new slice.</p>
<p>{{code &quot;/doc/progs/slices.go&quot; `/digit/` `/STOP/<a href="#id5"><span class="problematic" id="id6">`</span></a>}}</p>
<p>This code behaves as advertised, but the returned <code class="docutils literal notranslate"><span class="pre">[]byte</span></code> points into
an array containing the entire file. Since the slice references the
original array, as long as the slice is kept around the garbage
collector can't release the array; the few useful bytes of the file keep
the entire contents in memory.</p>
<p>To fix this problem one can copy the interesting data to a new slice
before returning it:</p>
<p>{{code &quot;/doc/progs/slices.go&quot; `/CopyDigits/` `/STOP/<a href="#id7"><span class="problematic" id="id8">`</span></a>}}</p>
<p>A more concise version of this function could be constructed by using
<code class="docutils literal notranslate"><span class="pre">append</span></code>. This is left as an exercise for the reader.</p>
<p><strong>Further Reading</strong></p>
<p><a class="reference external" href="/doc/effective_go.html">Effective Go</a> contains an in-depth treatment
of <a class="reference external" href="/doc/effective_go.html#slices">slices</a> and
<a class="reference external" href="/doc/effective_go.html#arrays">arrays</a>, and the Go <a class="reference external" href="/doc/go_spec.html">language
specification</a> defines
<a class="reference external" href="/doc/go_spec.html#Slice_types">slices</a> and their
<a class="reference external" href="/doc/go_spec.html#Length_and_capacity">associated</a>
<a class="reference external" href="/doc/go_spec.html#Making_slices_maps_and_channels">helper</a>
<a class="reference external" href="/doc/go_spec.html#Appending_and_copying_slices">functions</a>.</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div id="toc" class="sidebarRow">
    <h5><a href="index.html">The Go Blog</a></h5>
    <ul>
<li class="toctree-l1"><a class="reference internal" href="slices_usage_and_internals.html">Go Slices: usage and internals</a></li>
<li class="toctree-l1"><a class="reference internal" href="context.html">Go Concurrency Patterns: Context</a></li>
</ul>

    
</div>

<style type="text/css">
    .toctree-l1 {
        font-size: 12px;
        margin-bottom: 0;
        font-stretch: normal;
        font-style: normal;
        line-height: 1.33;
        padding-bottom: 5px;
        margin: 2px;
    }
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;VividCortex (translated by @d-tsuji).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/hoge.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>